name: "Setup Salesforce CLI"
description: "Enterprise-grade Salesforce CLI setup with authentication, caching, and optional tooling"
author: "Ryan Bumstead"

branding:
  icon: "zap"
  color: "blue"

inputs:
  # ============================================================================
  # CORE RUNTIME
  # ============================================================================
  node_version:
    description: "Node.js version"
    required: false
    default: "20"

  cli_version:
    description: "Salesforce CLI version (latest or explicit version like 2.x.x)"
    required: false
    default: "latest"

  cli_version_for_cache:
    description: "CLI version granularity for cache key (major, minor, or exact). Controls cache reuse vs freshness."
    required: false
    default: "minor"

  strict:
    description: "Fail pipeline on optional tool installation errors"
    required: false
    default: "false"

  # ============================================================================
  # AUTHENTICATION
  # ============================================================================
  skip_auth:
    description: "Skip authentication (CLI installation only)"
    required: false
    default: "false"

  auth_method:
    description: "Authentication method: 'jwt', 'sfdx-url', or 'access-token' (required unless skip_auth is true)"
    required: false
    default: "jwt"

  # JWT Authentication inputs
  jwt_key:
    description: "SFDX JWT Private Key (required when auth_method is 'jwt')"
    required: false

  client_id:
    description: "Connected App Client ID (required for 'jwt' and 'access-token' auth methods)"
    required: false

  username:
    description: "Salesforce Username (required when auth_method is 'jwt')"
    required: false

  # SFDX Auth URL inputs
  sfdx_auth_url:
    description: "SFDX Auth URL (required when auth_method is 'sfdx-url')"
    required: false

  # Direct Access Token inputs
  access_token:
    description: "Salesforce Access Token (required when auth_method is 'access-token')"
    required: false

  alias:
    description: "Org alias for authenticated org"
    required: false
    default: "TargetOrg"

  is_dev_hub:
    description: "Set org as default Dev Hub"
    required: false
    default: "false"

  instance_url:
    description: "Salesforce instance URL (required for 'jwt' and 'access-token' methods, e.g., https://login.salesforce.com)"
    required: false
    default: "https://login.salesforce.com"

  # ============================================================================
  # OPTIONAL TOOLING
  # ============================================================================
  install_delta:
    description: "Install sfdx-git-delta for delta deployments"
    required: false
    default: "false"

  install_scanner:
    description: "Install Salesforce Code Analyzer for static analysis"
    required: false
    default: "false"

  install_prettier:
    description: "Install Prettier with Salesforce plugins for code formatting"
    required: false
    default: "false"

  install_eslint:
    description: "Install ESLint with Salesforce plugins for linting"
    required: false
    default: "false"

  install_lwc_jest:
    description: "Install @salesforce/sfdx-lwc-jest for LWC unit testing"
    required: false
    default: "false"

  custom_sf_plugins:
    description: "Comma-separated list of additional Salesforce CLI plugins to install (e.g., 'sfdx-hardis,@salesforce/plugin-packaging')"
    required: false
    default: ""

  # ============================================================================
  # SOURCE DIRECTORY RESOLUTION
  # ============================================================================
  source_dirs:
    description: "Comma-separated source directories (e.g., 'force-app,packages/core')"
    required: false
    default: "force-app"

outputs:
  org_id:
    description: "Authenticated Salesforce Org ID"
    value: ${{ steps.detect-org.outputs.org_id }}

  org_edition:
    description: "Salesforce Edition (Developer, Enterprise, Unlimited, etc.)"
    value: ${{ steps.detect-org.outputs.org_edition }}

  org_type:
    description: "Organization type (Production, Sandbox, or Scratch)"
    value: ${{ steps.detect-org.outputs.org_type }}

  username:
    description: "Authenticated username"
    value: ${{ steps.detect-org.outputs.username }}

  instance_url:
    description: "Org instance URL"
    value: ${{ steps.detect-org.outputs.instance_url }}

  api_version:
    description: "Salesforce API version for the org"
    value: ${{ steps.detect-org.outputs.api_version }}

  auth_performed:
    description: "Whether authentication was performed (true) or skipped (false)"
    value: ${{ steps.auth-status.outputs.auth_performed }}

  sf_cli_version:
    description: "Installed Salesforce CLI version"
    value: ${{ steps.install-cli.outputs.cli_version }}

  source_flags:
    description: "Resolved source directory flags for SF CLI commands"
    value: ${{ steps.resolve-source-dirs.outputs.source_flags }}

runs:
  using: "composite"
  steps:
    # --------------------------------------------------------------------------
    # CORE SETUP
    # --------------------------------------------------------------------------
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ inputs.node_version }}

    - name: Detect Operating System
      id: detect-os
      shell: bash
      run: |
        echo "ðŸ” Detecting operating system..."

        case "${{ runner.os }}" in
          Linux)
            echo "os_type=linux" >> $GITHUB_OUTPUT
            echo "package_manager=apt" >> $GITHUB_OUTPUT
            echo "  âœ… OS: Linux (apt package manager)"
            ;;
          macOS)
            echo "os_type=macos" >> $GITHUB_OUTPUT
            echo "package_manager=brew" >> $GITHUB_OUTPUT
            echo "  âœ… OS: macOS (brew package manager)"
            ;;
          Windows)
            echo "os_type=windows" >> $GITHUB_OUTPUT
            echo "package_manager=choco" >> $GITHUB_OUTPUT
            echo "  âœ… OS: Windows (choco package manager)"
            ;;
          *)
            echo "os_type=unknown" >> $GITHUB_OUTPUT
            echo "package_manager=none" >> $GITHUB_OUTPUT
            echo "  âš ï¸  OS: Unknown"
            ;;
        esac

    - name: Ensure dependencies (jq) - Linux
      if: steps.detect-os.outputs.os_type == 'linux'
      shell: bash
      run: |
        if ! command -v jq &> /dev/null; then
          echo "ðŸ“¦ Installing jq on Linux..."
          sudo apt-get update && sudo apt-get install -y jq
          echo "  âœ… jq installed successfully"
        else
          echo "âœ… jq already installed"
        fi

    - name: Ensure dependencies (jq) - macOS
      if: steps.detect-os.outputs.os_type == 'macos'
      shell: bash
      run: |
        if ! command -v jq &> /dev/null; then
          echo "ðŸ“¦ Installing jq on macOS..."
          brew install jq
          echo "  âœ… jq installed successfully"
        else
          echo "âœ… jq already installed"
        fi

    - name: Ensure dependencies (jq) - Windows
      if: steps.detect-os.outputs.os_type == 'windows'
      shell: pwsh
      run: |
        if (!(Get-Command jq -ErrorAction SilentlyContinue)) {
          Write-Host "ðŸ“¦ Installing jq on Windows..."
          choco install jq -y
          Write-Host "  âœ… jq installed successfully"
        } else {
          Write-Host "âœ… jq already installed"
        }

    - name: Generate cache key
      id: cache-key
      shell: bash
      run: |
        echo "ðŸ”‘ Generating cache key..."

        # Tooling hash
        TOOLS_HASH=$(echo "${{ inputs.install_delta }}-${{ inputs.install_scanner }}-${{ inputs.install_prettier }}-${{ inputs.install_eslint }}-${{ inputs.install_lwc_jest }}-${{ inputs.custom_sf_plugins }}" \
          | sha256sum | cut -d' ' -f1 | cut -c1-8)

        echo "tools_hash=$TOOLS_HASH" >> $GITHUB_OUTPUT

        CLI_VERSION_INPUT="${{ inputs.cli_version }}"
        CLI_CACHE_VERSION=""

        if [ "$CLI_VERSION_INPUT" = "latest" ]; then
          echo "ðŸ“¦ Resolving actual Salesforce CLI version for cache..."

          # Ensure CLI is present to resolve version
          if ! command -v sf &> /dev/null; then
            npm install -g @salesforce/cli
          fi

          ACTUAL_VERSION=$(sf --version | head -n 1 | awk '{print $NF}')
          echo "  Detected CLI version: $ACTUAL_VERSION"

          case "${{ inputs.cli_version_for_cache }}" in
            major)
              CLI_CACHE_VERSION=$(echo "$ACTUAL_VERSION" | cut -d. -f1)
              ;;
            minor)
              CLI_CACHE_VERSION=$(echo "$ACTUAL_VERSION" | cut -d. -f1-2)
              ;;
            exact)
              CLI_CACHE_VERSION="$ACTUAL_VERSION"
              ;;
            *)
              CLI_CACHE_VERSION=$(echo "$ACTUAL_VERSION" | cut -d. -f1-2)
              ;;
          esac
        else
          case "${{ inputs.cli_version_for_cache }}" in
            major)
              CLI_CACHE_VERSION=$(echo "$CLI_VERSION_INPUT" | cut -d. -f1)
              ;;
            minor)
              CLI_CACHE_VERSION=$(echo "$CLI_VERSION_INPUT" | cut -d. -f1-2)
              ;;
            exact)
              CLI_CACHE_VERSION="$CLI_VERSION_INPUT"
              ;;
            *)
              CLI_CACHE_VERSION=$(echo "$CLI_VERSION_INPUT" | cut -d. -f1-2)
              ;;
          esac
        fi

        echo "cli_cache_version=$CLI_CACHE_VERSION" >> $GITHUB_OUTPUT
        echo "  âœ… Cache key uses CLI version: $CLI_CACHE_VERSION"
        echo "  âœ… Tools hash: $TOOLS_HASH"

    - name: Cache Salesforce CLI and plugins
      uses: actions/cache@v4
      with:
        path: |
          ~/.npm
          ~/.local/share/sf
          ~/.cache/node-gyp
          ~/AppData/Local/sf
          ~/AppData/Roaming/npm
        key: sf-v3-${{ runner.os }}-node${{ inputs.node_version }}-cli${{ steps.cache-key.outputs.cli_cache_version }}-tools${{ steps.cache-key.outputs.tools_hash }}
        restore-keys: |
          sf-v3-${{ runner.os }}-node${{ inputs.node_version }}-cli${{ steps.cache-key.outputs.cli_cache_version }}-
          sf-v3-${{ runner.os }}-node${{ inputs.node_version }}-

    - name: Install Salesforce CLI
      id: install-cli
      shell: bash
      run: |
        if ! command -v sf &> /dev/null; then
          echo "ðŸ“¦ Installing Salesforce CLI..."
          
          MAX_RETRIES=3
          RETRY_COUNT=0
          BASE_DELAY=5
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            # Calculate exponential backoff: 5s, 10s, 20s
            DELAY=$((BASE_DELAY * (2 ** RETRY_COUNT)))
            
            echo "  Attempt $((RETRY_COUNT + 1)) of $MAX_RETRIES..."
            
            if [ "${{ inputs.cli_version }}" = "latest" ]; then
              INSTALL_CMD="npm install -g @salesforce/cli"
            else
              INSTALL_CMD="npm install -g @salesforce/cli@${{ inputs.cli_version }}"
            fi
            
            if $INSTALL_CMD; then
              echo "  âœ… Salesforce CLI installed successfully"
              break
            fi
            
            RETRY_COUNT=$((RETRY_COUNT + 1))
            
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              echo "  âš ï¸  Installation failed, waiting ${DELAY}s before retry..."
              sleep $DELAY
            else
              echo "âŒ Failed to install Salesforce CLI after $MAX_RETRIES attempts"
              echo "ðŸ’¡ This may be due to:"
              echo "   - Network connectivity issues"
              echo "   - npm registry availability"
              echo "   - GitHub Actions rate limiting"
              echo "   - Retry the workflow or use a specific CLI version"
              exit 1
            fi
          done
        else
          echo "âœ… Salesforce CLI already installed"
        fi

        CLI_VERSION=$(sf --version | head -n 1)
        echo "ðŸ“Š Installed: $CLI_VERSION"
        echo "cli_version=$CLI_VERSION" >> $GITHUB_OUTPUT

    - name: Resolve Source Directories
      id: resolve-source-dirs
      shell: bash
      run: |
        RAW_INPUT="${{ inputs.source_dirs }}"
        [ -z "$RAW_INPUT" ] && RAW_INPUT="force-app"

        IFS=',' read -ra DIRS <<< "$RAW_INPUT"
        FLAGS=""
        HAS_VALID_DIR=false

        echo "ðŸ“ Resolving source directories..."

        for dir in "${DIRS[@]}"; do
          dir=$(echo "$dir" | xargs)
          
          if [ -d "$dir" ]; then
            FLAGS="$FLAGS --source-dir $dir"
            HAS_VALID_DIR=true
            echo "  âœ… Found: $dir"
          elif [ "$dir" == "force-app" ]; then
            echo "  âš ï¸  Default directory '$dir' not found. Creating it..."
            mkdir -p "$dir"
            FLAGS="$FLAGS --source-dir $dir"
            HAS_VALID_DIR=true
            echo "  âœ… Created: $dir"
          else
            echo "  âš ï¸  Warning: Directory '$dir' not found"
          fi
        done

        if [ "$HAS_VALID_DIR" = "false" ]; then
          echo "âŒ Error: No valid source directories found."
          exit 1
        fi

        echo "SF_SOURCE_FLAGS=$FLAGS" >> $GITHUB_ENV
        echo "source_flags=$FLAGS" >> $GITHUB_OUTPUT
        echo "âœ… Source directories resolved"

    # --------------------------------------------------------------------------
    # INPUT VALIDATION
    # --------------------------------------------------------------------------
    - name: Validate authentication inputs
      if: inputs.skip_auth != 'true'
      shell: bash
      run: |
        echo "ðŸ” Validating authentication inputs..."
        echo "  Auth method: ${{ inputs.auth_method }}"

        MISSING_INPUTS=()

        case "${{ inputs.auth_method }}" in
          jwt)
            echo "  Using JWT authentication"
            
            [ -z "${{ inputs.jwt_key }}" ] && MISSING_INPUTS+=("jwt_key")
            [ -z "${{ inputs.client_id }}" ] && MISSING_INPUTS+=("client_id")
            [ -z "${{ inputs.username }}" ] && MISSING_INPUTS+=("username")
            ;;
            
          sfdx-url)
            echo "  Using SFDX Auth URL authentication"
            
            [ -z "${{ inputs.sfdx_auth_url }}" ] && MISSING_INPUTS+=("sfdx_auth_url")
            ;;
            
          access-token)
            echo "  Using Direct Access Token authentication"
            
            [ -z "${{ inputs.access_token }}" ] && MISSING_INPUTS+=("access_token")
            [ -z "${{ inputs.instance_url }}" ] && MISSING_INPUTS+=("instance_url")
            ;;
            
          *)
            echo "âŒ Error: Invalid auth_method '${{ inputs.auth_method }}'"
            echo "   Must be one of: jwt, sfdx-url, access-token"
            exit 1
            ;;
        esac

        if [ ${#MISSING_INPUTS[@]} -gt 0 ]; then
          echo "âŒ Error: The following required inputs are missing for ${{ inputs.auth_method }} authentication:"
          printf '  - %s\n' "${MISSING_INPUTS[@]}"
          exit 1
        fi

        echo "âœ… Authentication inputs validated"

    # --------------------------------------------------------------------------
    # AUTHENTICATION
    # --------------------------------------------------------------------------
    - name: Authenticate Org (JWT)
      if: inputs.skip_auth != 'true' && inputs.auth_method == 'jwt'
      shell: bash
      env:
        JWT_KEY: ${{ inputs.jwt_key }}
      run: |
        set -e

        echo "ðŸ” Authenticating via JWT..."
        echo "  Client ID: ${{ inputs.client_id && '***' || '(not set)' }}"
        echo "  Username: ${{ inputs.username }}"
        echo "  Instance URL: ${{ inputs.instance_url }}"
        echo "  Alias: ${{ inputs.alias }}"

        # Create JWT key file with secure permissions using env var
        echo "$JWT_KEY" > jwt.key

        # Set secure permissions
        # Note: Linux (ubuntu-latest) is the recommended and supported runner
        if [[ "${{ runner.os }}" == "Windows" ]]; then
          echo "  âš ï¸  Windows runner detected - this is experimental and not recommended"
          echo "  âš ï¸  Use ubuntu-latest for production Salesforce CI/CD workflows"
          echo "  Setting Windows file permissions..."
          # Use GITHUB_ACTOR as fallback since USERNAME may not be reliable
          icacls jwt.key /inheritance:r
          icacls jwt.key /grant:r "${GITHUB_ACTOR}:(R)"
        else
          echo "  Setting file permissions..."
          chmod 600 jwt.key
        fi

        # Cleanup function
        cleanup() {
          echo "  ðŸ§¹ Cleaning up JWT key file..."
          rm -f jwt.key
        }
        trap cleanup EXIT

        # Build auth command
        AUTH_CMD="sf org login jwt \
          --client-id ${{ inputs.client_id }} \
          --jwt-key-file jwt.key \
          --username ${{ inputs.username }} \
          --instance-url ${{ inputs.instance_url }} \
          --alias ${{ inputs.alias }}"

        # Add dev hub or default flag
        if [ "${{ inputs.is_dev_hub }}" = "true" ]; then
          echo "  ðŸ”§ Setting as Dev Hub..."
          $AUTH_CMD --set-default-dev-hub
        else
          echo "  ðŸ”§ Setting as default org..."
          $AUTH_CMD --set-default
        fi

        echo "âœ… JWT authentication successful"

    - name: Authenticate Org (SFDX Auth URL)
      if: inputs.skip_auth != 'true' && inputs.auth_method == 'sfdx-url'
      shell: bash
      env:
        SFDX_AUTH_URL: ${{ inputs.sfdx_auth_url }}
      run: |
        set -e

        echo "ðŸ” Authenticating via SFDX Auth URL..."
        echo "  Alias: ${{ inputs.alias }}"

        # Create auth URL file with secure permissions using env var
        echo "$SFDX_AUTH_URL" > authurl.txt

        # Set secure permissions
        if [[ "${{ runner.os }}" == "Windows" ]]; then
          echo "  âš ï¸  Windows runner detected - use ubuntu-latest for production"
          icacls authurl.txt /inheritance:r
          icacls authurl.txt /grant:r "${GITHUB_ACTOR}:(R)"
        else
          chmod 600 authurl.txt
        fi

        # Cleanup function
        cleanup() {
          echo "  ðŸ§¹ Cleaning up auth URL file..."
          rm -f authurl.txt
        }
        trap cleanup EXIT

        # Authenticate using SFDX auth URL
        AUTH_CMD="sf org login sfdx-url \
          --sfdx-url-file authurl.txt \
          --alias ${{ inputs.alias }}"

        # Add dev hub or default flag
        if [ "${{ inputs.is_dev_hub }}" = "true" ]; then
          echo "  ðŸ”§ Setting as Dev Hub..."
          $AUTH_CMD --set-default-dev-hub
        else
          echo "  ðŸ”§ Setting as default org..."
          $AUTH_CMD --set-default
        fi

        echo "âœ… SFDX Auth URL authentication successful"

    - name: Authenticate Org (Access Token)
      if: inputs.skip_auth != 'true' && inputs.auth_method == 'access-token'
      shell: bash
      env:
        ACCESS_TOKEN: ${{ inputs.access_token }}
      run: |
        set -e

        echo "ðŸ” Authenticating via Direct Access Token..."
        echo "  âš ï¸  WARNING: Access tokens are short-lived and recommended for advanced use only"
        echo "  âš ï¸  For production workflows, use JWT or SFDX Auth URL authentication"
        echo "  Instance URL: ${{ inputs.instance_url }}"
        echo "  Alias: ${{ inputs.alias }}"

        # Create a secure auth file with the access token
        echo "$ACCESS_TOKEN" > access_token.txt

        # Set secure permissions
        if [[ "${{ runner.os }}" == "Windows" ]]; then
          echo "  âš ï¸  Windows runner detected - use ubuntu-latest for production"
          icacls access_token.txt /inheritance:r
          icacls access_token.txt /grant:r "${GITHUB_ACTOR}:(R)"
        else
          chmod 600 access_token.txt
        fi

        # Cleanup function
        cleanup() {
          echo "  ðŸ§¹ Cleaning up access token file..."
          rm -f access_token.txt authurl_token.txt
        }
        trap cleanup EXIT

        # SF CLI doesn't have a direct access token command, so we create an SFDX auth URL
        INSTANCE_URL_CLEAN=$(echo "${{ inputs.instance_url }}" | sed 's|https://||')

        # Note: client_id is optional for access token auth, use a placeholder if not provided
        CLIENT_ID_VALUE="${{ inputs.client_id }}"
        if [ -z "$CLIENT_ID_VALUE" ]; then
          CLIENT_ID_VALUE="PlatformCLI"
        fi

        AUTH_URL="force://$CLIENT_ID_VALUE::$ACCESS_TOKEN@$INSTANCE_URL_CLEAN"

        echo "$AUTH_URL" > authurl_token.txt
        if [[ "${{ runner.os }}" == "Windows" ]]; then
          icacls authurl_token.txt /inheritance:r
          icacls authurl_token.txt /grant:r "${GITHUB_ACTOR}:(R)"
        else
          chmod 600 authurl_token.txt
        fi

        sf org login sfdx-url \
          --sfdx-url-file authurl_token.txt \
          --alias ${{ inputs.alias }}

        # Add dev hub or default flag
        if [ "${{ inputs.is_dev_hub }}" = "true" ]; then
          echo "  ðŸ”§ Setting as Dev Hub..."
          sf config set target-dev-hub=${{ inputs.alias }}
        else
          echo "  ðŸ”§ Setting as default org..."
          sf config set target-org=${{ inputs.alias }}
        fi

        echo "âœ… Access Token authentication successful"

    - name: Detect Org Details
      id: detect-org
      if: inputs.skip_auth != 'true'
      shell: bash
      run: |
        set -e

        echo "ðŸ” Retrieving org details..."
        DETAILS=$(sf org display --target-org ${{ inputs.alias }} --json)

        # Extract org information with better fallbacks
        ORG_ID=$(echo "$DETAILS" | jq -r '.result.id // .result.orgId // "unknown"')
        ORG_EDITION=$(echo "$DETAILS" | jq -r '.result.edition // "unknown"')
        USERNAME=$(echo "$DETAILS" | jq -r '.result.username // "unknown"')
        INSTANCE_URL=$(echo "$DETAILS" | jq -r '.result.instanceUrl // "unknown"')
        API_VERSION=$(echo "$DETAILS" | jq -r '.result.apiVersion // "unknown"')

        # Try multiple fields for sandbox detection
        IS_SANDBOX=$(echo "$DETAILS" | jq -r '.result.isSandbox // false')
        IS_SCRATCH=$(echo "$DETAILS" | jq -r '.result.isScratchOrg // false')

        # Additional check: sandbox orgs often have instanceUrl containing "cs" or "sandbox"
        if [ "$IS_SANDBOX" = "false" ] && [[ "$INSTANCE_URL" =~ (cs[0-9]+|sandbox) ]]; then
          echo "  â„¹ï¸  Detected sandbox from instance URL pattern"
          IS_SANDBOX="true"
        fi

        # Check org namespace/status which can indicate sandbox
        ORG_STATUS=$(echo "$DETAILS" | jq -r '.result.status // "unknown"')
        ORG_TYPE_RAW=$(echo "$DETAILS" | jq -r '.result.organizationType // "unknown"')

        # Determine org type with improved logic
        if [ "$IS_SCRATCH" = "true" ]; then
          ORG_TYPE="Scratch"
        elif [ "$IS_SANDBOX" = "true" ]; then
          ORG_TYPE="Sandbox"
        elif [[ "$ORG_TYPE_RAW" =~ [Ss]andbox ]]; then
          ORG_TYPE="Sandbox"
        elif [[ "$ORG_EDITION" =~ Developer ]]; then
          # Developer editions are typically production but worth noting
          ORG_TYPE="Production"
        else
          ORG_TYPE="Production"
        fi

        # Set outputs
        echo "org_id=$ORG_ID" >> $GITHUB_OUTPUT
        echo "org_edition=$ORG_EDITION" >> $GITHUB_OUTPUT
        echo "org_type=$ORG_TYPE" >> $GITHUB_OUTPUT
        echo "username=$USERNAME" >> $GITHUB_OUTPUT
        echo "instance_url=$INSTANCE_URL" >> $GITHUB_OUTPUT
        echo "api_version=$API_VERSION" >> $GITHUB_OUTPUT

        # Display summary
        echo ""
        echo "ðŸ“Š Org Details Summary:"
        echo "  â”œâ”€ Type: $ORG_TYPE"
        echo "  â”œâ”€ Edition: $ORG_EDITION"
        echo "  â”œâ”€ Org ID: $ORG_ID"
        echo "  â”œâ”€ Username: $USERNAME"
        echo "  â”œâ”€ Instance: $INSTANCE_URL"
        echo "  â””â”€ API Version: $API_VERSION"
        echo ""

        if [ "$ORG_TYPE" = "Production" ] && [[ "$INSTANCE_URL" =~ (cs[0-9]+|sandbox) ]]; then
          echo "âš ï¸  WARNING: Org type detected as Production but instance URL suggests Sandbox"
          echo "   If this is incorrect, please report this issue with your org details"
        fi

    - name: Set Authentication Status
      id: auth-status
      shell: bash
      run: |
        if [ "${{ inputs.skip_auth }}" = "true" ]; then
          echo "auth_performed=false" >> $GITHUB_OUTPUT
          echo "â„¹ï¸  Authentication skipped"
        else
          echo "auth_performed=true" >> $GITHUB_OUTPUT
          echo "âœ… Authentication completed"
        fi

    # --------------------------------------------------------------------------
    # OPTIONAL TOOLING (with strict mode awareness)
    # --------------------------------------------------------------------------
    - name: Install sfdx-git-delta
      if: inputs.install_delta == 'true'
      shell: bash
      run: |
        if [ "${{ inputs.strict }}" = "true" ]; then
          set -e
        fi

        if ! sf plugins inspect sfdx-git-delta >/dev/null 2>&1; then
          echo "ðŸ“¦ Installing sfdx-git-delta..."
          echo y | sf plugins install sfdx-git-delta
          echo "  âœ… sfdx-git-delta installed"
        else
          echo "âœ… sfdx-git-delta already installed"
        fi

    - name: Install Salesforce Code Analyzer
      if: inputs.install_scanner == 'true'
      shell: bash
      run: |
        if [ "${{ inputs.strict }}" = "true" ]; then
          set -e
        fi

        if ! sf plugins inspect @salesforce/plugin-code-analyzer >/dev/null 2>&1; then
          echo "ðŸ“¦ Installing @salesforce/plugin-code-analyzer..."
          echo y | sf plugins install @salesforce/plugin-code-analyzer
          echo "  âœ… Code Analyzer installed"
        else
          echo "âœ… Code Analyzer already installed"
        fi

    - name: Install Custom Salesforce CLI Plugins
      if: inputs.custom_sf_plugins != ''
      shell: bash
      run: |
        if [ "${{ inputs.strict }}" = "true" ]; then
          set -e
        fi

        echo "ðŸ“¦ Installing custom Salesforce CLI plugins..."

        IFS=',' read -ra PLUGIN_LIST <<< "${{ inputs.custom_sf_plugins }}"
        FAILED_PLUGINS=()
        INSTALLED_PLUGINS=()
        SKIPPED_PLUGINS=()

        for plugin in "${PLUGIN_LIST[@]}"; do
          # Trim whitespace
          plugin=$(echo "$plugin" | xargs)
          
          # Skip empty entries
          if [ -z "$plugin" ]; then
            continue
          fi
          
          # Validate plugin name format (alphanumeric, hyphens, underscores, @ for scopes)
          if ! echo "$plugin" | grep -qE '^(@[a-zA-Z0-9-]+\/)?[a-zA-Z0-9@_-]+$'; then
            echo "  âš ï¸  Invalid plugin name format: '$plugin'"
            echo "     Plugin names should match: [@scope/]plugin-name"
            FAILED_PLUGINS+=("$plugin (invalid format)")
            if [ "${{ inputs.strict }}" = "true" ]; then
              exit 1
            fi
            continue
          fi
          
          # Check if already installed
          if sf plugins inspect "$plugin" >/dev/null 2>&1; then
            echo "  âœ… $plugin already installed"
            SKIPPED_PLUGINS+=("$plugin")
            continue
          fi
          
          # Install the plugin
          echo "  ðŸ“¦ Installing: $plugin"
          if echo y | sf plugins install "$plugin" 2>&1; then
            echo "    âœ… Installed successfully"
            INSTALLED_PLUGINS+=("$plugin")
          else
            echo "    âŒ Failed to install"
            FAILED_PLUGINS+=("$plugin")
            if [ "${{ inputs.strict }}" = "true" ]; then
              exit 1
            fi
          fi
        done

        # Summary
        echo ""
        echo "ðŸ“Š Plugin Installation Summary:"
        echo "   â”œâ”€ Installed: ${#INSTALLED_PLUGINS[@]}"
        echo "   â”œâ”€ Already Present: ${#SKIPPED_PLUGINS[@]}"
        echo "   â””â”€ Failed: ${#FAILED_PLUGINS[@]}"

        if [ ${#FAILED_PLUGINS[@]} -gt 0 ]; then
          echo ""
          echo "âš ï¸  Failed Plugins:"
          printf '   - %s\n' "${FAILED_PLUGINS[@]}"
          
          if [ "${{ inputs.strict }}" = "true" ]; then
            echo ""
            echo "âŒ Strict mode enabled: Failing workflow due to plugin errors"
            exit 1
          else
            echo ""
            echo "ðŸ’¡ Non-strict mode: Continuing despite failures"
            echo "   Set strict: 'true' to fail on plugin errors"
          fi
        fi

    - name: Install Prettier and plugins
      if: inputs.install_prettier == 'true'
      shell: bash
      run: |
        if [ "${{ inputs.strict }}" = "true" ]; then
          set -e
        fi

        if ! command -v prettier &> /dev/null; then
          echo "ðŸ“¦ Installing Prettier with Salesforce plugins..."
          npm install --global prettier prettier-plugin-apex @prettier/plugin-xml
          echo "  âœ… Prettier installed"
        else
          echo "âœ… Prettier already installed"
        fi

    - name: Install ESLint and plugins
      if: inputs.install_eslint == 'true'
      shell: bash
      run: |
        if [ "${{ inputs.strict }}" = "true" ]; then
          set -e
        fi

        if ! command -v eslint &> /dev/null; then
          echo "ðŸ“¦ Installing ESLint with Salesforce plugins..."
          npm install --global eslint @salesforce/eslint-config-lwc @lwc/eslint-plugin-lwc
          echo "  âœ… ESLint installed"
        else
          echo "âœ… ESLint already installed"
        fi

    - name: Install sfdx-lwc-jest
      if: inputs.install_lwc_jest == 'true'
      shell: bash
      run: |
        if [ "${{ inputs.strict }}" = "true" ]; then
          set -e
        fi

        if ! npm list -g @salesforce/sfdx-lwc-jest &> /dev/null; then
          echo "ðŸ“¦ Installing @salesforce/sfdx-lwc-jest..."
          npm install --global @salesforce/sfdx-lwc-jest
          echo "  âœ… sfdx-lwc-jest installed"
        else
          echo "âœ… sfdx-lwc-jest already installed"
        fi

    # --------------------------------------------------------------------------
    # FINAL STATUS
    # --------------------------------------------------------------------------
    - name: Environment Ready
      shell: bash
      run: |
        echo ""
        echo "ðŸŽ‰ Salesforce environment is ready!"
        echo ""
        echo "ðŸ“Š Installed Tools:"
        echo "  â”œâ”€ Salesforce CLI: $(sf --version | head -n 1)"
        [ "${{ inputs.install_delta }}" = "true" ] && echo "  â”œâ”€ sfdx-git-delta: âœ…" || true
        [ "${{ inputs.install_scanner }}" = "true" ] && echo "  â”œâ”€ Code Analyzer: âœ…" || true
        [ "${{ inputs.install_prettier }}" = "true" ] && echo "  â”œâ”€ Prettier: âœ…" || true
        [ "${{ inputs.install_eslint }}" = "true" ] && echo "  â”œâ”€ ESLint: âœ…" || true
        [ "${{ inputs.install_lwc_jest }}" = "true" ] && echo "  â””â”€ LWC Jest: âœ…" || true

        if [ -n "${{ inputs.custom_sf_plugins }}" ]; then
          echo ""
          echo "ðŸ”Œ Custom Plugins:"
          IFS=',' read -ra PLUGIN_LIST <<< "${{ inputs.custom_sf_plugins }}"
          PLUGIN_COUNT=${#PLUGIN_LIST[@]}
          INDEX=0
          for plugin in "${PLUGIN_LIST[@]}"; do
            plugin=$(echo "$plugin" | xargs)
            INDEX=$((INDEX + 1))
            if [ -n "$plugin" ]; then
              if [ $INDEX -eq $PLUGIN_COUNT ]; then
                echo "  â””â”€ $plugin"
              else
                echo "  â”œâ”€ $plugin"
              fi
            fi
          done
        fi

        echo ""
        echo "âœ… Setup complete - ready for Salesforce operations!"
